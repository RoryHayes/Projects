#pragma config(Sensor, S1,     LeftLight,      sensorLightActive)
#pragma config(Sensor, S2,     RightLight,     sensorLightActive)
#pragma config(Sensor, S4,     Sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          RightWheel,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          LeftWheel,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          TheClaw,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//**** FUNCTION LIST ****
void turningLeft();
void turningRight();
void forward();
void reverse();
void LineDetection();
void claw();
void releaseclaw();
void ahead();
void curDirFix();
void updatePos();
void proceeder();
void cease();
void halfForward();

#define ROWS 11
#define COLS 9
#define SPEED 30
#define TURNRO 198
#define BLACKSENS 46
#define SLOWSPEED 10

int curDir;
int curX, curY;
int map[ROWS][COLS];
int boxAhead;
int boxBehind;
int boxLeft;
int boxRight;
int hasBlock=0;


task main()
{
		int i,j;

		//down-across

		/*
		Unchecked: 0
		Checked Empty:1
		Block: 2
		Mine: 3
		Edge: 4
		Safezone: 5
		*/

		for(i=0;i<ROWS;i++)
		{
			for(j=0;j<COLS;j++)
			{
				map[i][j]=0;
			}
		}

		for(i=0;i<ROWS;i++)
		{
			//col A 1-11
			map[i][0]=4;
			map[i][8]=4;
		}
		for(i=0;i<COLS;i++)
		{
			//row 11 A-I
			map[10][i]=4;
		}
		for(i=1;i<COLS-1;i++)
		{
			map[0][i]=5;
		}


		//curPos = map[9][4];
		curX=9;
		curY=4;
		curDir = 0;

		proceeder();

}

//START FUNCTION LEFT TURN
void turningLeft()
{
	nMotorEncoder[motorA] = 0;
	while(nMotorEncoder[motorA] < TURNRO)
	{
		motor[motorA] = SPEED;
		motor[motorB] = -SPEED;
	}
	curDir--;
	curDirFix();
}//END FUNCTION LEFT TURN


//START FUCTION RIGHT TURN
void turningRight()
{
	nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < TURNRO)
	{
		motor[motorA] = -SPEED;
		motor[motorB] = SPEED;
	}
	curDir++;
	curDirFix();
}//END FUNCTION RIGHT TURN


//START FUNCTION FORWARD
void forward()
{
	int roationAmount = 270;
	nMotorEncoder[motorA] = 0; // Reset the Motor Encoder of Motor B.
	nMotorEncoder[motorB] = 0; // Reset the Motor Encoder of Motor B.
	while(nMotorEncoder[motorA] < roationAmount && nMotorEncoder[motorB] < roationAmount) // While the Motor Encoder of Motor B has not yet reached 360 counts:
	{
		motor[motorA] = SPEED; // Motor B is given a power level of 75.
		motor[motorB] = SPEED; // Motor C is given a power level of 75.
		claw();
	}
	updatePos();

}//END FUNCTION FORWARD

//START HALFFUNCTION FORWARD
void halfForward()
{
	int roationAmount = 135;
	nMotorEncoder[motorA] = 0; // Reset the Motor Encoder of Motor B.
	nMotorEncoder[motorB] = 0; // Reset the Motor Encoder of Motor B.
	while(nMotorEncoder[motorA] < roationAmount && nMotorEncoder[motorB] < roationAmount) // While the Motor Encoder of Motor B has not yet reached 360 counts:
	{
		motor[motorA] = SPEED; // Motor B is given a power level of 75.
		motor[motorB] = SPEED; // Motor C is given a power level of 75.
		claw();
	}
	updatePos();

}//END HALFFUNCTION FORWARD

//START FUNCTIN REVERSE
void reverse()
{
	nMotorEncoder[motorA] = 0; // Reset the Motor Encoder of Motor B.
	while(nMotorEncoder[motorA] < 340) // While the Motor Encoder of Motor B has not yet reached 360 counts:
	{
		motor[motorA] = SPEED; // Motor B is given a power level of 75.
		motor[motorB] = -SPEED; // Motor C is given a power level of 75.
	}
}//END FUNCTION REVERSE

void cease()
{
		motor[motorA] = 0;
		motor[motorB] = 0;
}


//START FUNCTINON LINE DETECTION
void LineDetection()
{
	//Detect a line, then detect if its still black after

	if(SensorValue(RightLight) < BLACKSENS && SensorValue(LeftLight) < BLACKSENS) //ON black line
	{
		int crawl = 110;//DEFINE THE AMOUNT OF ROTATIONS ACCORDING TO THE SIZE OF LINE???

		int roationAmount = crawl;
		nMotorEncoder[motorA] = 0; // Reset the Motor Encoder of Motor B.
		nMotorEncoder[motorB] = 0; // Reset the Motor Encoder of Motor B.
		while(nMotorEncoder[motorA] < roationAmount && nMotorEncoder[motorB] < roationAmount) // While the Motor Encoder of Motor B has not yet reached 360 counts:
		{
			motor[motorA] = SLOWSPEED; // Motor B is given a power level of 75.
			motor[motorB] = SLOWSPEED; // Motor C is given a power level of 75.
			claw();
		}
		//IF STILL ON BLACK
		if(SensorValue(RightLight) < BLACKSENS && SensorValue(LeftLight) < BLACKSENS)
		{
			//ITS A TRAP!! (A Mine)
			ahead();
			boxAhead=3;
			//REVERSE Back the rotations used
			//Dont update position
			nMotorEncoder[motorA] = 0; // Reset the Motor Encoder of Motor B.
			nMotorEncoder[motorB] = 0; // Reset the Motor Encoder of Motor B.
			while(nMotorEncoder[motorA] < roationAmount && nMotorEncoder[motorB] < roationAmount) // While the Motor Encoder of Motor B has not yet reached 360 counts:
			{
				motor[motorA] = -SLOWSPEED; // Motor B is given a power level of 75.
				motor[motorB] = -SLOWSPEED; // Motor C is given a power level of 75.
				claw();
			}
			}
			else
			{
				boxAhead=1;
				//continue, finish the rotations and update the position
				roationAmount = 270-crawl;
				nMotorEncoder[motorA] = 0; // Reset the Motor Encoder of Motor B.
				nMotorEncoder[motorB] = 0; // Reset the Motor Encoder of Motor B.
				while(nMotorEncoder[motorA] < roationAmount && nMotorEncoder[motorB] < roationAmount) // While the Motor Encoder of Motor B has not yet reached 360 counts:
				{
					motor[motorA] = SPEED; // Motor B is given a power level of 75.
					motor[motorB] = SPEED; // Motor C is given a power level of 75.
					claw();
				}
				updatePos();

			}
	}

}//END FUNCTION LINE DETECTOIN


//START FUNCTION THE CLAW
void claw()
{
	int dist = 8;

	if(SensorValue[Sonar] <= dist)
	{
		motor[motorC] = 100;
		hasBlock=1;
		wait1Msec(200);
	}
}//END THE CLAW FUNCTION


//START FUNCTION RELEASE CLAW
void releaseclaw()
{
	motor[motorC] = -100;
	wait1Msec(200);
}//END RELEASE CLAW FUCTION



//START FUNCTION AHEAD
void ahead()
{
	boxAhead = map[curX+1][curY+1];

	switch(curDir)
	{
		//North
		case 0:
		boxAhead = map[curX-1][curY];
		boxRight = map[curX][curY+1];
		boxBehind = map[curX+1][curY];
		boxLeft= map[curX][curY-1];
		break;

		//East
		case 1:
		boxAhead = map[curX][curY+1];
		boxRight = map[curX+1][curY];
		boxBehind = map[curX][curY-1];
		boxLeft= map[curX-1][curY];
		break;

		//South
		case 2:
		boxAhead = map[curX+1][curY];
		boxRight = map[curX][curY-1];
		boxBehind = map[curX-1][curY];
		boxLeft= map[curX][curY+1];
		break;

		//West
		case 3:
		boxAhead = map[curX][curY-1];
		boxRight = map[curX-1][curY];
		boxBehind = map[curX][curY+1];
		boxLeft= map[curX+1][curY];
		break;
	}


}//END FUNCTION AHEAD

//START CURDIRFIX
void curDirFix()
{
	while(curDir<0)
	{
			curDir=3;
	}
	while(curDir>3)
	{
			curDir=0;
	}
}
//END CURDIRFIX

//START UPDATEPOS
void updatePos()
{
	switch(curDir)
	{
		//North
		case 0:
		//boxAhead = map[curX-1][curY];
		curX--;
		map[curX][curY]=1;
		break;

		//East
		case 1:
		//boxAhead = map[curX][curY+1];
		curY++;
		map[curX][curY]=1;
		break;

		//South
		case 2:
		//boxAhead = map[curX+1][curY];
		curX++;
		map[curX][curY]=1;
		break;

		//West
		case 3:
		//boxAhead = map[curX][curY-1];
		curY--;
		map[curX][curY]=1;
		break;
	}
}
//END UPDATEPOS

//START PROCEEDOR
void proceeder()
{
	ahead();

	//Box ahead is unchecked
	if(boxAhead==0)
	{
		LineDetection()
	}

  //Facing safe zone while holding a block
	if(boxAhead==5&&hasBlock==1)
	{
		halfForward();
		cease();
		releaseclaw();
		StopAllTasks();

	}

  //If surrounded by checked areas
	if (boxAhead==3||boxAhead==4||boxAhead==1||boxAhead==5)
	{
		if(boxRight==3||boxRight==4||boxRight==1||boxRight==5)
		{
			if(boxLeft==3||boxLeft==4||boxLeft==1||boxLeft==5)
			{
				if(boxBehind==3||boxBehind==4||boxBehind==1||boxBehind==5)
				{
          //If surrounded on all sides but the box ahead is clear but already checked **AVOID CONSTANT LOOPING**
					if (boxAhead==1)
					{
						forward();
					}
					else
					{
						turningRight();
					}
				}
			}
		}
        //Clear on the right then:
        else
        {
            turningRight();
            proceeder();
        }

	}//END IF

  //Okay to go ahead
  else
  {
      forward();
      proceeder();
  }

}
//END PROCEEDOR
